<!DOCTYPE html>
<html translate="no">
<head>
    <meta charset="UTF-8">
    <meta name="google" content="notranslate">
    <title>DS MCO PLAYER</title>
    <script src="{{ url_for('static', filename='socket.io.min.js') }}"></script>
    <link href="{{ url_for('static', filename='css/player.css') }}" rel="stylesheet" />
</head>
<body>
    <div id="status-indicator" onclick="toggleDebugPanel()" title="Cliquez pour voir les infos de debug"></div>

    <div id="debug-panel">
        <div style="font-weight: bold; margin-bottom: 10px; color: #667eea;">üêõ Informations de debug</div>
        <div class="debug-line"><strong>√âtat:</strong> <span id="debug-status-text">D√©connect√©</span></div>
        <div class="debug-line"><strong>√âcran:</strong> <span id="debug-screen-id">--</span></div>
        <div class="debug-line"><strong>Playlist:</strong> <span id="debug-playlist-name">Aucune</span></div>
        <div class="debug-line"><strong>Contenu:</strong> <span id="debug-content-name">Aucun</span></div>
        <div class="debug-line"><strong>Index:</strong> <span id="debug-index">--</span></div>
        <div class="debug-line"><strong>Temps √©coul√©:</strong> <span id="debug-elapsed">--</span></div>
        <div class="debug-line"><strong>Dur√©e totale:</strong> <span id="debug-duration">--</span></div>
        <div class="debug-line"><strong>Affichage prioritaire:</strong> <span id="debug-priority-active" style="font-weight: bold;">Non</span></div>
        <div class="debug-line"><strong>Derni√®re v√©rif:</strong> <span id="debug-last-check">--</span></div>
    </div>

    <div id="content-container">
        <div class="waiting">En attente de contenu...</div>
    </div>

    <div id="clock-display" style="display: none;"></div>

    <script>
        const socket = io();
        const screenId = new URLSearchParams(window.location.search).get('id');
        const screenName = new URLSearchParams(window.location.search).get('name') || '√âcran ' + screenId;
        let playlistInterval = null;
        let contentTimeout = null; // Timeout pour la dur√©e d'un contenu simple
        let currentPlaylistIndex = 0;
        let currentPlaylist = [];
        let schedule = [];
        let screensPlaylists = {}; // CORRECTION: Variable initialis√©e
        let contentLibrary = []; // Biblioth√®que de contenus
        let activeScheduledPlaylistId = null; // Suivre quelle playlist planifi√©e est active
        let defaultContentId = null; // Contenu par d√©faut
        let idleBehavior = 'show_default'; // Comportement entre plages horaires
        let currentContentStartTime = null; // Temps de d√©but du contenu actuel
        let currentContentDuration = 0; // Dur√©e du contenu actuel
        let currentContentName = null; // Nom du contenu actuel (pour affichage)
        let currentPlaylistName = null; // Nom de la playlist active
        let currentPlaylistIsPriority = false; // Si la playlist actuelle est prioritaire
        let isPriorityActive = false; // Si un contenu/playlist prioritaire est actif
        let showClock = false; // Affichage de l'horloge
        let clockInterval = null; // Intervalle de mise √† jour de l'horloge

        // Fonction pour mettre √† jour l'horloge
        function updateClock() {
            if (!showClock) return;

            const now = new Date();
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const seconds = String(now.getSeconds()).padStart(2, '0');

            const clockElement = document.getElementById('clock-display');
            clockElement.textContent = `${hours}:${minutes}:${seconds}`;
        }

        // Fonction pour d√©marrer/arr√™ter l'horloge
        function toggleClock(show) {
            showClock = show;
            const clockElement = document.getElementById('clock-display');

            if (show) {
                clockElement.style.display = 'block';
                updateClock(); // Mise √† jour imm√©diate
                if (!clockInterval) {
                    clockInterval = setInterval(updateClock, 1000);
                }
            } else {
                clockElement.style.display = 'none';
                if (clockInterval) {
                    clearInterval(clockInterval);
                    clockInterval = null;
                }
            }
        }

        // Fonction pour basculer le panneau de debug
        function toggleDebugPanel() {
            const panel = document.getElementById('debug-panel');
            panel.classList.toggle('open');
        }

        // Fonction pour formater les secondes en HH:MM:SS
        function formatTime(seconds) {
            if (!seconds || seconds === 0) return '00:00:00';
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = seconds % 60;
            return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
        }

        // Fonction pour mettre √† jour les infos de debug dans le panneau
        function updateDebugPanel() {
            screenIdText = screenId || '--';
            const screenIdElement = document.getElementById('debug-screen-id');
            // tronque l'ID de l'√©cran s'il est trop long
            if (screenIdText.length > 20) {
                screenIdElement.title = screenIdText; // Afficher le nom complet au survol
                screenIdText = screenIdText.slice(0, 17) + '...';
            } else {
                screenIdElement.removeAttribute('title');
            }
            screenIdElement.textContent = screenIdText;

            playlist_text = currentPlaylistName || 'Aucune';
            const playlistElement = document.getElementById('debug-playlist-name');
            if (playlist_text.length > 20) {
                playlistElement.title = playlist_text; // Afficher le nom complet au survol
                playlist_text = playlist_text.slice(0, 17) + '...';
            } else {
                playlistElement.removeAttribute('title');
            }
            playlistElement.textContent = playlist_text;

            // Afficher le nom du contenu actuel
            let displayContentName = 'Aucun';
            if (currentPlaylist.length > 0 && currentPlaylist[currentPlaylistIndex]) {
                displayContentName = currentPlaylist[currentPlaylistIndex].content.name;
            } else if (currentContentName) {
                displayContentName = currentContentName;
            }
            const contentElement = document.getElementById('debug-content-name');
            // tronque le nom du contenu si trop long
            if (displayContentName.length > 20) {
                contentElement.title = displayContentName; // Afficher le nom complet au survol
                displayContentName = displayContentName.slice(0, 17) + '...';
            } else {
                contentElement.removeAttribute('title');
            }
            contentElement.textContent = displayContentName;

            if (currentPlaylist.length > 0) {
                document.getElementById('debug-index').textContent = `${currentPlaylistIndex + 1}/${currentPlaylist.length}`;
            } else {
                document.getElementById('debug-index').textContent = '--';
            }

            if (currentContentStartTime) {
                const elapsed = Math.floor((Date.now() - currentContentStartTime) / 1000);
                document.getElementById('debug-elapsed').textContent = formatTime(elapsed);
            } else {
                document.getElementById('debug-elapsed').textContent = '00:00:00';
            }

            document.getElementById('debug-duration').textContent = currentContentDuration > 0 ? formatTime(currentContentDuration) : '‚àû (infini)';

            // Afficher l'√©tat de l'affichage prioritaire
            const priorityElement = document.getElementById('debug-priority-active');
            if (isPriorityActive) {
                priorityElement.textContent = '‚ö° OUI';
                priorityElement.style.color = '#f5576c';
            } else {
                priorityElement.textContent = 'Non';
                priorityElement.style.color = '#999';
            }

            document.getElementById('debug-last-check').textContent = new Date().toLocaleTimeString();
        }

        // Mettre √† jour le panneau de debug toutes les secondes
        setInterval(updateDebugPanel, 1000);

        socket.on('connect', () => {
            const indicator = document.getElementById('status-indicator');
            indicator.className = 'online';
            document.getElementById('debug-status-text').textContent = 'üü¢ Connect√©';
            document.getElementById('debug-status-text').style.color = '#28a745';

            socket.emit('register_screen', {
                screen_id: screenId,
                name: screenName,
                location: new URLSearchParams(window.location.search).get('location') || 'Non d√©fini'
            });
            console.log('‚úÖ Connect√© au serveur avec ID:', screenId);
        });

        socket.on('disconnect', () => {
            const indicator = document.getElementById('status-indicator');
            indicator.className = 'offline';
            document.getElementById('debug-status-text').textContent = 'üî¥ D√©connect√©';
            document.getElementById('debug-status-text').style.color = '#dc3545';
            console.log('‚ùå D√©connect√© du serveur');
        });

        socket.on('reload_page', () => {
            console.log('üîÑ Rechargement de la page demand√© par le serveur');
            location.reload();
        });

        socket.on('state_update', (data) => {
            //console.log("üì¢ Mise √† jour de l'√©tat re√ßue:", data);
            screensPlaylists = data.playlists;
            contentLibrary = data.content;
        });

        // CORRECTION: R√©ception de la liste compl√®te des playlists
        socket.on('send_full_playlist_list', (data) => {
            if (data.screen_id === screenId || !data.screen_id) {
                screensPlaylists = data.playlists;
                console.log('üìã Playlists re√ßues:', Object.keys(screensPlaylists).length);
            }
        });

        // R√©ception de la biblioth√®que de contenus
        socket.on('send_content_library', (data) => {
            if (data.screen_id === screenId || !data.screen_id) {
                contentLibrary = data.content;
                console.log('üìö Biblioth√®que de contenus re√ßue:', contentLibrary.length);
                // V√©rifier si un contenu par d√©faut doit √™tre affich√© maintenant que la biblioth√®que est charg√©e
                checkSchedule();
            }
        });

        // CORRECTION: R√©ception du planning
        socket.on('update_schedule', (data) => {
            if (data.screen_id === screenId) {
                schedule = data.schedule || [];
                console.log('üìÖ Planning mis √† jour:', schedule);
                // R√©initialiser la playlist active pour forcer la v√©rification
                //activeScheduledPlaylistId = null;
                // V√©rifier imm√©diatement si une playlist doit √™tre lanc√©e
                checkSchedule();
            }
        });

        // R√©ception de la configuration de l'√©cran
        socket.on('config_updated', (data) => {
            if (data.screen_id === screenId) {
                defaultContentId = data.default_content_id;
                idleBehavior = data.idle_behavior || 'show_default';

                // G√©rer l'affichage de l'horloge
                if (data.show_clock !== undefined) {
                    toggleClock(data.show_clock);
                }

                console.log('‚öôÔ∏è Configuration mise √† jour:', { defaultContentId, idleBehavior, showClock: data.show_clock });

                // Si aucune playlist planifi√©e n'est active, forcer l'affichage du contenu par d√©faut
                if (activeScheduledPlaylistId === null) {
                    console.log('   ‚Üí Aucune playlist planifi√©e active, application imm√©diate de la config');
                    // Arr√™ter toute playlist en cours (manuelle ou ancienne)
                    stopPlaylist();
                    // Afficher le contenu par d√©faut
                    showDefaultContent();
                } else {
                    // Si une playlist planifi√©e est active, juste v√©rifier l'√©tat
                    console.log('   ‚Üí Playlist planifi√©e active, v√©rification du planning');
                    checkSchedule();
                }
            }
        });

        // V√©rification du planning toutes les 10 secondes pour plus de pr√©cision
        setInterval(checkSchedule, 10000);

        function checkSchedule() {
            // Ne pas v√©rifier le planning si un contenu prioritaire est en cours
            if (isPriorityActive) {
                console.log('‚è∞ Contenu prioritaire en cours, planning ignor√©');
                return;
            }

            if (!schedule || schedule.length === 0) {
                console.log('‚è∞ Pas de planning d√©fini');
                // Si pas de planning, r√©initialiser la playlist planifi√©e active
                if (activeScheduledPlaylistId !== null) {
                    activeScheduledPlaylistId = null;
                }
                // Afficher le contenu par d√©faut s'il n'y a pas de playlist en cours
                if (idleBehavior === 'show_default') {  
                    showDefaultContent();
                }
                return;
            }

            const now = new Date();
            const currentTime = now.toTimeString().slice(0, 5); // HH:MM
            console.log('‚è∞ V√©rification du planning √†', currentTime);

            // Trouver la playlist qui doit √™tre active maintenant
            let targetPlaylistId = null;

            for (const entry of schedule) {
                console.log(`   Plage horaire: ${entry.start} - ${entry.end}`);

                // V√©rification de la plage horaire
                if (entry.start <= currentTime && currentTime <= entry.end) {
                    targetPlaylistId = entry.playlist_id;
                    console.log(`   ‚úÖ Dans la plage! Playlist ID:`, targetPlaylistId);
                    break; // On prend la premi√®re correspondance
                }
            }

            console.log("activeScheduledPlaylistId:", activeScheduledPlaylistId);
            console.log("targetPlaylistId:", targetPlaylistId);

            // Si on a trouv√© une playlist planifi√©e et qu'elle est diff√©rente de celle active
            if (targetPlaylistId && targetPlaylistId !== activeScheduledPlaylistId) {
                if (screensPlaylists && screensPlaylists[targetPlaylistId]) {
                    const playlist = screensPlaylists[targetPlaylistId];
                    console.log('   üìã FOR√áAGE du lancement de la playlist:', playlist.name);

                    // Arr√™ter la playlist actuelle (force l'arr√™t m√™me si une autre est en cours)
                    stopPlaylist();

                    // M√©moriser quelle playlist planifi√©e est maintenant active
                    activeScheduledPlaylistId = targetPlaylistId;
                    currentPlaylistName = playlist.name; // Stocker le nom de la playlist

                    // D√©marrer la nouvelle playlist
                    currentPlaylist = playlist.items;
                    currentPlaylistIndex = 0;
                    playNextInPlaylist();
                } else {
                    console.log('   ‚ö†Ô∏è Playlist introuvable:', targetPlaylistId);
                }
            } else if (!targetPlaylistId && activeScheduledPlaylistId !== null) {
                // Plus aucune playlist planifi√©e n'est active
                console.log('   ‚è∞ Fin de la plage horaire planifi√©e');
                activeScheduledPlaylistId = null;

                // G√©rer le comportement entre les plages horaires
                if (idleBehavior === 'show_default') {
                    console.log('   üì∫ Affichage du contenu par d√©faut');
                    showDefaultContent();
                } else {
                    console.log('   üîÅ Continuation de la derni√®re playlist');
                    // Ne rien faire, la playlist continue
                }
            } else if (targetPlaylistId === activeScheduledPlaylistId) {
                console.log('   ‚úì Playlist planifi√©e d√©j√† active:', targetPlaylistId);
            } else if (!targetPlaylistId) {
                console.log('   ‚è∞ Aucune playlist programm√©e pour le moment');
                // Si aucune playlist planifi√©e et aucune n'est active, afficher le contenu par d√©faut
                if (activeScheduledPlaylistId === null && currentPlaylist.length === 0) {
                    showDefaultContent();
                }
            }
        }

        function showDefaultContent() {
            console.log('üîÑ showDefaultContent() appel√©');
            console.log('   - defaultContentId:', defaultContentId);
            console.log('   - contentLibrary.length:', contentLibrary.length);
            console.log('   - currentPlaylist.length:', currentPlaylist.length);

            if (!defaultContentId) {
                console.log('   ‚ÑπÔ∏è Pas de contenu par d√©faut d√©fini');
                stopPlaylist();
                document.getElementById('content-container').innerHTML =
                    '<div class="waiting">En attente de contenu...</div>';
                return;
            }

            // Trouver le contenu par d√©faut dans la biblioth√®que
            const defaultContent = contentLibrary.find(c => c.id === defaultContentId);

            if (!defaultContent) {
                console.log('   ‚ö†Ô∏è Contenu par d√©faut introuvable dans la biblioth√®que:', defaultContentId);
                console.log('   Contenus disponibles:', contentLibrary.map(c => c.id));
                return;
            }

            console.log('   ‚úÖ Contenu par d√©faut trouv√©:', defaultContent.name);
            console.log('   üì∫ Affichage du contenu par d√©faut...');
            stopPlaylist();
            displayContent(defaultContent);
        }

        function displayContent(content) {
            console.log('üé¨ displayContent() appel√© pour:', content.name, '(type:', content.type + ')');
            const container = document.getElementById('content-container');
            container.innerHTML = '';

            // Mettre √† jour les infos de debug
            currentContentStartTime = Date.now();
            currentContentDuration = content.duration || 0;
            currentContentName = content.name;

            if (content.type === 'url') {
                console.log('   ‚Üí Affichage URL:', content.url);
                container.innerHTML = `<iframe src="${content.url}" allowfullscreen></iframe>`;
            } else if (content.type === 'video') {
                container.innerHTML = `
                    <video src="${content.url}" autoplay loop controls>
                        Votre navigateur ne supporte pas la vid√©o.
                    </video>
                `;
            } else if (content.type === 'image') {
                container.innerHTML = `<img src="${content.url}" alt="Image">`;
            } else if (content.type === 'youtube') {
                const videoId = content.url.match(/(?:youtube\.com\/watch\?v=|youtu\.be\/)([^&]+)/)?.[1];
                if (videoId) {
                    container.innerHTML = `
                        <iframe src="https://www.youtube.com/embed/${videoId}?autoplay=1&mute=1&controls=1&playsinline=1&rel=0&modestbranding=1&loop=1&playlist=${videoId}"
                                allow="autoplay; encrypted-media"
                                allowfullscreen></iframe>
                    `;
                }
            }
        }

        socket.on('show_content', (data) => {
            // G√©rer le nouveau format {content: ..., priority: ...} ou l'ancien format direct
            const content = data.content || data;
            const isPriority = data.priority || false;

            console.log('üì∫ Affichage du contenu manuel:', content.name);

            // IMPORTANT: Marquer comme prioritaire IMM√âDIATEMENT pour bloquer checkSchedule()
            isPriorityActive = isPriority;

            // Arr√™ter toute playlist en cours
            stopPlaylist();

            // Annuler le timeout de contenu pr√©c√©dent s'il existe
            if (contentTimeout) {
                clearTimeout(contentTimeout);
                contentTimeout = null;
            }

            // R√©initialiser la playlist planifi√©e active (affichage manuel)
            activeScheduledPlaylistId = null;

            // Mettre √† jour les infos de debug
            currentContentStartTime = Date.now();
            currentContentDuration = content.duration || 0;
            currentContentName = content.name;

            const container = document.getElementById('content-container');
            container.innerHTML = '';

            if (content.type === 'url') {
                container.innerHTML = `<iframe src="${content.url}" allowfullscreen></iframe>`;
            } else if (content.type === 'video') {
                container.innerHTML = `
                    <video src="${content.url}" autoplay loop controls>
                        Votre navigateur ne supporte pas la vid√©o.
                    </video>
                `;
            } else if (content.type === 'image') {
                container.innerHTML = `<img src="${content.url}" alt="Image">`;
            } else if (content.type === 'youtube') {
                const videoId = content.url.match(/(?:youtube\.com\/watch\?v=|youtu\.be\/)([^&]+)/)?.[1];
                if (videoId) {
                    container.innerHTML = `
                        <iframe src="https://www.youtube.com/embed/${videoId}?autoplay=1&mute=1&controls=1&playsinline=1&rel=0&modestbranding=1&loop=1&playlist=${videoId}"
                                allow="autoplay; encrypted-media"
                                allowfullscreen></iframe>
                    `;
                }
            }

            if (content.duration > 0) {
                contentTimeout = setTimeout(() => {
                    contentTimeout = null;
                    isPriorityActive = false; // Fin du contenu prioritaire

                    // Si c'est un affichage prioritaire
                    if (isPriority) {
                        // Notifier le serveur pour mettre √† jour les infos
                        socket.emit('clear_screen', { screen_id: screenId });
                        // Reprendre le planning apr√®s la fin du contenu prioritaire
                        checkSchedule();
                    } else {
                        // Pour les contenus non-prioritaires, afficher "Contenu termin√©"
                        container.innerHTML = '<div class="waiting">Contenu termin√©</div>';
                    }
                }, content.duration * 1000);
            }
        });

        socket.on('clear_content', () => {
            console.log('üßπ Effacement de l\'√©cran');
            document.getElementById('content-container').innerHTML =
                '<div class="waiting">En attente de contenu...</div>';
            stopPlaylist();
            // Annuler le timeout de contenu s'il existe
            if (contentTimeout) {
                clearTimeout(contentTimeout);
                contentTimeout = null;
            }
            // R√©initialiser la playlist planifi√©e active
            activeScheduledPlaylistId = null;
            isPriorityActive = false; // R√©initialiser le flag prioritaire
            currentContentName = null;
            currentContentStartTime = null;
        });

        socket.on('start_playlist', (data) => {
            console.log('üìã D√©marrage de la playlist manuelle:', data.name);

            // IMPORTANT: Marquer comme prioritaire IMM√âDIATEMENT pour bloquer checkSchedule()
            const isPriority = data.priority || false;
            isPriorityActive = isPriority;
            currentPlaylistIsPriority = isPriority;

            stopPlaylist();
            // Annuler le timeout de contenu s'il existe
            if (contentTimeout) {
                clearTimeout(contentTimeout);
                contentTimeout = null;
            }
            // R√©initialiser la playlist planifi√©e active (c'est une playlist manuelle)
            activeScheduledPlaylistId = null;
            currentPlaylist = data.items;
            currentPlaylistIndex = 0;
            currentPlaylistName = data.name; // Stocker le nom de la playlist
            playNextInPlaylist();
        });

        function stopPlaylist() {
            if (playlistInterval) {
                clearTimeout(playlistInterval);
                playlistInterval = null;
                console.log('‚èπÔ∏è Playlist arr√™t√©e');
            }
            currentPlaylist = [];
            currentPlaylistIndex = 0;
            currentContentName = null;
            currentPlaylistName = null;
            currentPlaylistIsPriority = false;
        }

        function playNextInPlaylist() {
            if (currentPlaylist.length === 0) {
                console.log('‚ö†Ô∏è Playlist vide');
                return;
            }

            const item = currentPlaylist[currentPlaylistIndex];
            const content = item.content;
            const duration = item.duration;

            console.log(`‚ñ∂Ô∏è Lecture ${currentPlaylistIndex + 1}/${currentPlaylist.length}: ${content.name} (${duration}s)`);

            // Mettre √† jour les infos de debug
            currentContentStartTime = Date.now();
            currentContentDuration = duration;

            // Afficher le contenu
            const container = document.getElementById('content-container');
            container.innerHTML = '';

            if (content.type === 'url') {
                container.innerHTML = `<iframe src="${content.url}" allowfullscreen></iframe>`;
            } else if (content.type === 'video') {
                container.innerHTML = `
                    <video src="${content.url}" autoplay loop controls>
                        Votre navigateur ne supporte pas la vid√©o.
                    </video>
                `;
            } else if (content.type === 'image') {
                container.innerHTML = `<img src="${content.url}" alt="Image">`;
            } else if (content.type === 'youtube') {
                const videoId = content.url.match(/(?:youtube\.com\/watch\?v=|youtu\.be\/)([^&]+)/)?.[1];
                if (videoId) {
                    container.innerHTML = `
                        <iframe src="https://www.youtube.com/embed/${videoId}?autoplay=1&mute=1&controls=1&playsinline=1&rel=0&modestbranding=1&loop=1&playlist=${videoId}"
                                allow="autoplay; encrypted-media"
                                allowfullscreen></iframe>
                    `;
                }
            }

            // Programmer le prochain contenu
            playlistInterval = setTimeout(() => {
                currentPlaylistIndex++;

                // Si c'est une playlist prioritaire et qu'on a fini tous les √©l√©ments
                if (currentPlaylistIsPriority && currentPlaylistIndex >= currentPlaylist.length) {
                    console.log('‚úÖ Playlist prioritaire termin√©e');
                    stopPlaylist();
                    isPriorityActive = false; // Fin de la playlist prioritaire
                    // Notifier le serveur pour mettre √† jour les infos
                    socket.emit('clear_screen', { screen_id: screenId });
                    // Reprendre le planning apr√®s la fin de la playlist prioritaire
                    checkSchedule();
                } else {
                    // Playlist normale : boucler
                    currentPlaylistIndex = currentPlaylistIndex % currentPlaylist.length;
                    playNextInPlaylist();
                }
            }, duration * 1000);
        }

        // Envoyer les informations de debug toutes les 5 secondes
        setInterval(() => {
            const elapsedTime = currentContentStartTime
                ? (Date.now() - currentContentStartTime) / 1000
                : 0;

            // D√©terminer le nom du contenu actuel (sans "Playlist:")
            let currentItemName = null;
            if (currentPlaylist.length > 0 && currentPlaylist[currentPlaylistIndex]) {
                const currentItem = currentPlaylist[currentPlaylistIndex];
                currentItemName = currentItem.content.name;
            } else if (currentContentName) {
                currentItemName = currentContentName;
            }

            const debugInfo = {
                screen_id: screenId,
                current_playlist_name: currentPlaylistName, // Nom de la playlist
                current_content_name: currentItemName, // Nom du contenu actuel
                playlist_index: currentPlaylist.length > 0 ? currentPlaylistIndex : null,
                playlist_length: currentPlaylist.length,
                elapsed_time: elapsedTime,
                current_duration: currentContentDuration,
                is_priority_active: isPriorityActive // Affichage prioritaire en cours
            };

            socket.emit('update_debug_info', debugInfo);
        }, 5000);

        // V√©rifier le planning au chargement de la page
        setTimeout(() => {
            checkSchedule();
        }, 2000);
    </script>
</body>
</html>